[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "At RtoProd.com, we bridge the gap between R development and full-scale production. We understand that taking R code from development to production-ready can be challenging - but possible. Our platform is dedicated to simplifying and accelerating this process by sharing proven insights, tools, and techniques to streamline deployment on modern infrastructure.\nOur team is composed of experts with diverse technical backgrounds, bringing together deep expertise in data science, software engineering, and DevOps. This blend of expertise allows us to tackle the unique demands of production environments, from creating robust data pipelines and APIs to deploying Shiny applications and scaling machine learning models.\nThrough our blog posts, tutorials, and resources, we aim to empower teams to harness the full potential of R in production settings. Whether you’re building an end-to-end data pipeline, deploying a machine learning model, or creating an interactive web app, RtoProd.com is here to guide you in making your code work seamlessly at scale.\nJoin us as we explore best practices, cloud-native technologies, and the latest advancements in R deployment to help you confidently transition your R code from prototype to production."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html",
    "href": "posts/create-your-gcp-account/index.html",
    "title": "Create Your Google Cloud Account",
    "section": "",
    "text": "Welcome to the first blog post on RtoProd.com! Our mission is to provide tips, tricks, and insights to help you transition your R code to production-grade infrastructure.\nBefore diving into the technical aspects of deploying R applications, the very first thing we need is an account on a production-grade infrastructure platform. In this post, we’ll guide you through creating a Google Cloud Platform (GCP) account. GCP offers a robust and scalable environment perfect for hosting R applications, pipelines, and APIs. By following this tutorial, you’ll set up your account and gain access to $300 in free credits.\nIn addition to the free credits, GCP offers a range of free-tier services that you can use indefinitely under specified limits. You can find a complete list of free-tier services here."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#welcome-to-rtoprod.com",
    "href": "posts/create-your-gcp-account/index.html#welcome-to-rtoprod.com",
    "title": "Create Your Google Cloud Account",
    "section": "",
    "text": "Welcome to the first blog post on RtoProd.com! Our mission is to provide tips, tricks, and insights to help you transition your R code to production-grade infrastructure.\nBefore diving into the technical aspects of deploying R applications, the very first thing we need is an account on a production-grade infrastructure platform. In this post, we’ll guide you through creating a Google Cloud Platform (GCP) account. GCP offers a robust and scalable environment perfect for hosting R applications, pipelines, and APIs. By following this tutorial, you’ll set up your account and gain access to $300 in free credits.\nIn addition to the free credits, GCP offers a range of free-tier services that you can use indefinitely under specified limits. You can find a complete list of free-tier services here."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#why-choose-google-cloud",
    "href": "posts/create-your-gcp-account/index.html#why-choose-google-cloud",
    "title": "Create Your Google Cloud Account",
    "section": "Why Choose Google Cloud?",
    "text": "Why Choose Google Cloud?\nGoogle Cloud Platform is an excellent choice for deploying R projects due to its scalability, compatibility with R tools, and a wide range of services. While other cloud providers like AWS and Azure are equally viable, we focus on GCP because it’s what we’re most comfortable with. Other cloud service providers are as recommended as GCP, and most of the services and procedures remain similar.\nWe recommend creating a new account for each project. First, to keep projects encapsulated in their own account, making it easier to manage and organize resources. Second, because Google offers $300 in credits for every new account, providing a great opportunity to experiment with their services at no cost."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#step-by-step-guide-to-creating-a-google-cloud-account",
    "href": "posts/create-your-gcp-account/index.html#step-by-step-guide-to-creating-a-google-cloud-account",
    "title": "Create Your Google Cloud Account",
    "section": "Step-by-Step Guide to Creating a Google Cloud Account",
    "text": "Step-by-Step Guide to Creating a Google Cloud Account\nThis guide covers everything from signing up to completing the payment setup. Don’t worry—your payment method won’t be charged until your $300 free credits are either spent or expire in 90 days. Let’s get started!\n\nVisit https://cloud.google.com/.\nClick the “Start Free” button.\n\n\n\nClick “Create account”, then choose “For work or my business” (or another option that suits your needs).\n\n\n\nClick “Get a Gmail address”.\n\n\n\nEnter your First and Last names, and then click on “Next”.\n\n\n\nFill in your birthdate and Gender, and click on “Next”.\n\n\n\nClick “Get a Gmail address instead”.\n\n\n\nFill in your Username (we recommend a name related to the new project), and click “Next”.\n\n\n\nFill in your Password, and click “Next”.\n\n\n\nFill in your Phone number, and click “Next”. This step is safe; you won’t be charged anything to your phone number, and you can use your number for as many accounts as you need.\n\n\n\nEnter the verification code you receive via SMS, and click “Next”.\n\n\n\nAdd a Recovery email (we recommend using your most used email), and click “Next”.\n\n\n\nFill in your Phone number again, and click “Next”.\n\n\n\nIf a screen pops up stating that your phone number is already in use for another account, click “Continue creating a new account”.\n\n\n\nJust click “Skip”.\n\n\n\nClick “Next”.\n\n\n\nThoroughly read the terms and conditions, and click “I agree” (if you agree).\n\n\n\nClick “Not Now”.\n\n\n\nFill in your business country, and click “Agree & continue” (if you agree with the terms).\n\n\n\nClick “Start free”.\n\n\n\nFill in your payments profile. Here, we use the “Individual” profile type.\n\n\n\nClick “Start free”.\n\n\n\nFill in your payment method details. Here, we’ve used a credit card.\n\n\n\nAdd your credit card information. It won’t be charged until your free credits expire, at which point you can decide whether to continue paying or disable non-free-tier services.\n\n\n\nClick “Start free”.\n\n\n\nClick “Done”.\n\n\n\nThat’s it! Your account is now ready to use, with free-tier services enabled, and you’ve got $300 in credits to use within the next 3 months."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#creating-your-first-project-optional",
    "href": "posts/create-your-gcp-account/index.html#creating-your-first-project-optional",
    "title": "Create Your Google Cloud Account",
    "section": "Creating Your First Project (Optional)",
    "text": "Creating Your First Project (Optional)\nWhile it’s perfectly fine to start with the default “My First Project” assigned by Google Cloud, creating a dedicated project for each of your R deployments helps you organize resources more effectively. It’s a simple process and a great habit to adopt.\n\nClick on “My First Project”.\n\n\n\nClick “NEW PROJECT”.\n\n\n\nEnter the new “Project name”, and then click “CREATE”.\n\n\n\nWait a few moments for the new project to be created. Once the green checkmark appears, click “SELECT PROJECT” to start using your new project."
  },
  {
    "objectID": "posts/add-user-auth/index.html",
    "href": "posts/add-user-auth/index.html",
    "title": "Enable Google Cloud Platform Managed User Auth",
    "section": "",
    "text": "In this post, we’ll walk through the process of enabling and configuring Google Cloud Platform’s (GCP) Identity Provider for R projects. Authentication and user management are critical for building secure and scalable applications. While it’s possible to implement your own authentication methods, doing so can introduce vulnerabilities, increase development time, and require ongoing maintenance to address security risks and compliance.\nGCP’s Identity Provider simplifies authentication workflows, offering a robust, managed solution that handles the heavy lifting for you. Whether you’re deploying Shiny apps, APIs, or R scripts on GCP, integrating a managed authentication service ensures ease of use, enhanced security, and scalability.\nThis guide provides a step-by-step approach to help you get started, leveraging GCP’s free-tier features wherever possible.\nLet’s dive in and set up secure user authentication for your R projects!\n\n\n\nThe email/password provider is the simplest authentication method to configure, making it an excellent starting point. In this post, we’ll focus on enabling this method to get you started quickly and effectively. In future posts, we’ll explore how to work with other authentication providers to expand your app’s capabilities. Here’s how to enable the email/password identity provider:\n\nLog in to the Google Cloud console, and search for “Identity Platform” using the search bar. Click on the “Identity Platform” service.\n\n\n\nClick the “ENABLE IDENTITY PLATFORM” button to activate the service.\n\n\n\nTo add an identity provider, click “ADD A PROVIDER”.\n\n\n\nFrom the dropdown menu, select and click “Email / Password”.\n\n\n\nConfigure the email provider settings. The default options should work perfectly for most use cases. Once configured, click “SAVE”.\n\n\n\nAfter saving, click “APPLICATION SETUP DETAILS” to access the service’s API key.\n\n\n\nCopy the “apiKey” and store it securely. This key will be used in your applications to authenticate with the Identity Platform.\n\n\n\nThat’s it! Your GCP Identity Platform is now set up with the Email/Password authentication provider, ready for use in your R projects.\n\n\n\n\n\n\nNow that the Identity Platform is set up, you can integrate authentication into your R projects using the API key, also referred as “FIREBASE_API_KEY”. First, set your Firebase API key as an environment variable.\nSys.setenv(FIREBASE_API_KEY = \"your-apiKey-here\")\nWith the API key in place, you have multiple options for integrating authentication into your R projects. You can either use the custom functions provided below, which directly interact with the Firebase Auth REST API, or opt for the firebase R package for a more streamlined approach.\nThe following custom functions demonstrate how to handle common authentication tasks such as signing in, signing up, resetting passwords, verifying emails, and fetching user data. These functions make secure API calls to the Firebase Auth REST API to interact with your GCP Identity Platform:\nbox::use(\n  httr[content, POST]\n)\n\nif (nchar(Sys.getenv(\"FIREBASE_API_KEY\")) == 0) {\n  stop(\"Set `FIREBASE_API_KEY` env var to handle user auths.\")\n}\n\napi_url &lt;- \"https://identitytoolkit.googleapis.com/v1/accounts\"\n\n#' Sign in with email / password\n#' @param email The email the user is signing in with.\n#' @param password The password for the account.\n#' @export\nemail_signin &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signInWithPassword?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Sign up with email / password\n#' @param email The email for the user to create.\n#' @param password The password for the user to create.\n#' @export\nemail_signup &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signUp?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send password reset email\n#' @param email User's email address.\n#' @export\nreset_password &lt;- function(email) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, requestType = \"PASSWORD_RESET\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send email verification\n#' @param id_token The Firebase ID token of the user to verify.\n#' @export\nemail_verification &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token, requestType = \"VERIFY_EMAIL\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Get user data\n#' @param id_token The Firebase ID token of the account.\n#' @export\nget_user_data &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":lookup?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res, as = \"parsed\", simplifyVector = TRUE)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\nThese functions make it easy to manage user authentication directly within your R projects, enabling secure sign-ins, sign-ups, password resets, email verification, and more.\nFor a full integration, you can test this functionality within a simple Shiny app:\n# App imports.\nbox::use(\n  shiny[\n    actionButton, br, conditionalPanel, div, fluidPage, modalButton, modalDialog, observeEvent,\n    outputOptions, passwordInput, reactive, reactiveVal, removeModal, renderText, req, shinyApp,\n    showModal, showNotification, textInput, verbatimTextOutput\n  ],\n  shinyvalidate[InputValidator, sv_email]\n)\n\n# UI definition for the app.\nui &lt;- fluidPage(\n  div(\n    align = \"center\",\n    br(),\n    # If it's logged in show \"Logout\", in the other case show \"Login\".\n    conditionalPanel(\"!output.logged_in\", actionButton(\"login\", \"Login / Signup\")),\n    conditionalPanel(\n      \"output.logged_in\",\n      # Displays a message with the logged-in user's email when logged in.\n      verbatimTextOutput(\"logged_msg\"),\n      actionButton(\"logout\", \"Logout\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  # Reactive value to store authentication status (whether user is logged in or not).\n  r_user_auth &lt;- reactiveVal(list(signed_in = FALSE))\n  # Reactive output to control the visibility of login/logout button based on auth status.\n  output$logged_in &lt;- reactive(r_user_auth()$signed_in)\n  outputOptions(output, \"logged_in\", suspendWhenHidden = FALSE)\n\n  # Modal dialog for login/signup.\n  auth_modal &lt;- modalDialog(\n    title = \"Login to Your Account\",\n    div(\n      align = \"center\",\n      # Inputs for email and password.\n      textInput(\"user_email\", label = NULL, placeholder = \"Email\", width = \"100%\"),\n      passwordInput(\"user_password\", label = NULL, placeholder = \"Password\", width = \"100%\"),\n      # Buttons for submitting login or signup request.\n      actionButton(\"login_submit\", \"Login\"),\n      actionButton(\"signup_submit\", \"Signup\"),\n      modalButton(\"Cancel\")\n    ),\n    footer = NULL,\n    easyClose = TRUE\n  )\n  # Input validation setup using shinyvalidate.\n  iv &lt;- InputValidator$new()\n  iv$add_rule(\"user_email\", sv_email())\n  # Custom password length validation.\n  sv_min_nchar &lt;- function(value) {\n    if (nchar(value) &lt; 8) {\n      \"The password must have at least 8 characters lenght\"\n    }\n  }\n  iv$add_rule(\"user_password\", sv_min_nchar)\n\n  # Server functions.\n  # Show the login modal when 'Login' is clicked.\n  observeEvent(input$login, showModal(auth_modal))\n  observeEvent(input$login_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    login_res &lt;- email_signin(user_email, user_pass)\n    if (!login_res$success) {\n      showNotification(\"Couldn't log in, please check your email and password!\", type = \"error\")\n    } else {\n      # On successful login, update user state and close modal.\n      user_data &lt;- get_user_data(login_res$idToken) # Fetch user data.\n      user_data$signed_in &lt;- TRUE\n      r_user_auth(user_data)\n      removeModal()\n    }\n  })\n  observeEvent(input$signup_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    signup_res &lt;- email_signup(user_email, user_pass)\n    if (!signup_res$success) {\n      showNotification(\"Couldn't sign up, please check your email and password!\", type = \"error\")\n    } else {\n      showNotification(\"Signed up, succesfully! Please login now.\")\n    }\n  })\n  observeEvent(input$logout, {\n    showNotification(\"Logged out, succesfully!\") # Notify user of successful logout.\n    r_user_auth(list(signed_in = FALSE)) # Reset auth status to logged out.\n  })\n\n  # Display logged-in user's email.\n  output$logged_msg &lt;- renderText({\n    req(r_user_auth()$signed_in) # Ensure the user is signed in.\n    paste0(\"Hi \", r_user_auth()$users$email, \"!\") # Greet the user by email.\n  })\n}\n\nshinyApp(ui, server)\nThis Shiny app integrates the authentication functions, allowing users to sign in, sign up, and log out, all while interacting with the GCP Identity Platform system. You can use this as a template to quickly build secure authentication workflows in your own applications."
  },
  {
    "objectID": "posts/add-user-auth/index.html#enable-google-cloud-platform-managed-user-auth",
    "href": "posts/add-user-auth/index.html#enable-google-cloud-platform-managed-user-auth",
    "title": "Enable Google Cloud Platform Managed User Auth",
    "section": "",
    "text": "In this post, we’ll walk through the process of enabling and configuring Google Cloud Platform’s (GCP) Identity Provider for R projects. Authentication and user management are critical for building secure and scalable applications. While it’s possible to implement your own authentication methods, doing so can introduce vulnerabilities, increase development time, and require ongoing maintenance to address security risks and compliance.\nGCP’s Identity Provider simplifies authentication workflows, offering a robust, managed solution that handles the heavy lifting for you. Whether you’re deploying Shiny apps, APIs, or R scripts on GCP, integrating a managed authentication service ensures ease of use, enhanced security, and scalability.\nThis guide provides a step-by-step approach to help you get started, leveraging GCP’s free-tier features wherever possible.\nLet’s dive in and set up secure user authentication for your R projects!\n\n\n\nThe email/password provider is the simplest authentication method to configure, making it an excellent starting point. In this post, we’ll focus on enabling this method to get you started quickly and effectively. In future posts, we’ll explore how to work with other authentication providers to expand your app’s capabilities. Here’s how to enable the email/password identity provider:\n\nLog in to the Google Cloud console, and search for “Identity Platform” using the search bar. Click on the “Identity Platform” service.\n\n\n\nClick the “ENABLE IDENTITY PLATFORM” button to activate the service.\n\n\n\nTo add an identity provider, click “ADD A PROVIDER”.\n\n\n\nFrom the dropdown menu, select and click “Email / Password”.\n\n\n\nConfigure the email provider settings. The default options should work perfectly for most use cases. Once configured, click “SAVE”.\n\n\n\nAfter saving, click “APPLICATION SETUP DETAILS” to access the service’s API key.\n\n\n\nCopy the “apiKey” and store it securely. This key will be used in your applications to authenticate with the Identity Platform.\n\n\n\nThat’s it! Your GCP Identity Platform is now set up with the Email/Password authentication provider, ready for use in your R projects.\n\n\n\n\n\n\nNow that the Identity Platform is set up, you can integrate authentication into your R projects using the API key, also referred as “FIREBASE_API_KEY”. First, set your Firebase API key as an environment variable.\nSys.setenv(FIREBASE_API_KEY = \"your-apiKey-here\")\nWith the API key in place, you have multiple options for integrating authentication into your R projects. You can either use the custom functions provided below, which directly interact with the Firebase Auth REST API, or opt for the firebase R package for a more streamlined approach.\nThe following custom functions demonstrate how to handle common authentication tasks such as signing in, signing up, resetting passwords, verifying emails, and fetching user data. These functions make secure API calls to the Firebase Auth REST API to interact with your GCP Identity Platform:\nbox::use(\n  httr[content, POST]\n)\n\nif (nchar(Sys.getenv(\"FIREBASE_API_KEY\")) == 0) {\n  stop(\"Set `FIREBASE_API_KEY` env var to handle user auths.\")\n}\n\napi_url &lt;- \"https://identitytoolkit.googleapis.com/v1/accounts\"\n\n#' Sign in with email / password\n#' @param email The email the user is signing in with.\n#' @param password The password for the account.\n#' @export\nemail_signin &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signInWithPassword?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Sign up with email / password\n#' @param email The email for the user to create.\n#' @param password The password for the user to create.\n#' @export\nemail_signup &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signUp?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send password reset email\n#' @param email User's email address.\n#' @export\nreset_password &lt;- function(email) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, requestType = \"PASSWORD_RESET\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send email verification\n#' @param id_token The Firebase ID token of the user to verify.\n#' @export\nemail_verification &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token, requestType = \"VERIFY_EMAIL\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Get user data\n#' @param id_token The Firebase ID token of the account.\n#' @export\nget_user_data &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":lookup?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res, as = \"parsed\", simplifyVector = TRUE)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\nThese functions make it easy to manage user authentication directly within your R projects, enabling secure sign-ins, sign-ups, password resets, email verification, and more.\nFor a full integration, you can test this functionality within a simple Shiny app:\n# App imports.\nbox::use(\n  shiny[\n    actionButton, br, conditionalPanel, div, fluidPage, modalButton, modalDialog, observeEvent,\n    outputOptions, passwordInput, reactive, reactiveVal, removeModal, renderText, req, shinyApp,\n    showModal, showNotification, textInput, verbatimTextOutput\n  ],\n  shinyvalidate[InputValidator, sv_email]\n)\n\n# UI definition for the app.\nui &lt;- fluidPage(\n  div(\n    align = \"center\",\n    br(),\n    # If it's logged in show \"Logout\", in the other case show \"Login\".\n    conditionalPanel(\"!output.logged_in\", actionButton(\"login\", \"Login / Signup\")),\n    conditionalPanel(\n      \"output.logged_in\",\n      # Displays a message with the logged-in user's email when logged in.\n      verbatimTextOutput(\"logged_msg\"),\n      actionButton(\"logout\", \"Logout\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  # Reactive value to store authentication status (whether user is logged in or not).\n  r_user_auth &lt;- reactiveVal(list(signed_in = FALSE))\n  # Reactive output to control the visibility of login/logout button based on auth status.\n  output$logged_in &lt;- reactive(r_user_auth()$signed_in)\n  outputOptions(output, \"logged_in\", suspendWhenHidden = FALSE)\n\n  # Modal dialog for login/signup.\n  auth_modal &lt;- modalDialog(\n    title = \"Login to Your Account\",\n    div(\n      align = \"center\",\n      # Inputs for email and password.\n      textInput(\"user_email\", label = NULL, placeholder = \"Email\", width = \"100%\"),\n      passwordInput(\"user_password\", label = NULL, placeholder = \"Password\", width = \"100%\"),\n      # Buttons for submitting login or signup request.\n      actionButton(\"login_submit\", \"Login\"),\n      actionButton(\"signup_submit\", \"Signup\"),\n      modalButton(\"Cancel\")\n    ),\n    footer = NULL,\n    easyClose = TRUE\n  )\n  # Input validation setup using shinyvalidate.\n  iv &lt;- InputValidator$new()\n  iv$add_rule(\"user_email\", sv_email())\n  # Custom password length validation.\n  sv_min_nchar &lt;- function(value) {\n    if (nchar(value) &lt; 8) {\n      \"The password must have at least 8 characters lenght\"\n    }\n  }\n  iv$add_rule(\"user_password\", sv_min_nchar)\n\n  # Server functions.\n  # Show the login modal when 'Login' is clicked.\n  observeEvent(input$login, showModal(auth_modal))\n  observeEvent(input$login_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    login_res &lt;- email_signin(user_email, user_pass)\n    if (!login_res$success) {\n      showNotification(\"Couldn't log in, please check your email and password!\", type = \"error\")\n    } else {\n      # On successful login, update user state and close modal.\n      user_data &lt;- get_user_data(login_res$idToken) # Fetch user data.\n      user_data$signed_in &lt;- TRUE\n      r_user_auth(user_data)\n      removeModal()\n    }\n  })\n  observeEvent(input$signup_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    signup_res &lt;- email_signup(user_email, user_pass)\n    if (!signup_res$success) {\n      showNotification(\"Couldn't sign up, please check your email and password!\", type = \"error\")\n    } else {\n      showNotification(\"Signed up, succesfully! Please login now.\")\n    }\n  })\n  observeEvent(input$logout, {\n    showNotification(\"Logged out, succesfully!\") # Notify user of successful logout.\n    r_user_auth(list(signed_in = FALSE)) # Reset auth status to logged out.\n  })\n\n  # Display logged-in user's email.\n  output$logged_msg &lt;- renderText({\n    req(r_user_auth()$signed_in) # Ensure the user is signed in.\n    paste0(\"Hi \", r_user_auth()$users$email, \"!\") # Greet the user by email.\n  })\n}\n\nshinyApp(ui, server)\nThis Shiny app integrates the authentication functions, allowing users to sign in, sign up, and log out, all while interacting with the GCP Identity Platform system. You can use this as a template to quickly build secure authentication workflows in your own applications."
  },
  {
    "objectID": "posts/assign-custom-domain/index.html",
    "href": "posts/assign-custom-domain/index.html",
    "title": "Assign a Custom Domain to a Google Cloud Run Service",
    "section": "",
    "text": "In this post, we’ll guide you through assigning a custom domain to a Google Cloud Run Service, such as the one we deployed in our previous post. Using Google Cloud Run’s Domain Mappings feature, we’ll map your Shiny app to a memorable domain name like “everysinglecountry.com”.\n\n\nBefore we begin, ensure that:\n\nYour Shiny app is deployed in one of the supported regions for Domain Mappings.\nYou have already purchased a domain. For this example, we bought “everysinglecountry.com” at Porkbun for $11.06/year. You can use any registrar as the steps are similar.\n\nLet’s get started!\n\n\n\n\n\nLog in to the Google Cloud console and open the Navigation menu (three horizontal lines icon).\n\n\n\nSelect “Cloud Run”.\n\n\n\nClick “MANAGE CUSTOM DOMAINS”.\n\n\n\nClick “ADD MAPPING”.\n\n\n\nSelect your service, such as “everysinglecountry”.\n\n\n\nClick “Cloud Run Domain Mappings”.\n\n\n\nEnter your domain name (e.g., “everysinglecountry.com”) and click “CONTINUE”.\n\n\n\nClick “VERIFY IN SEARCH CONSOLE” to validate ownership.\n\n\n\nEnter the domain name in the “Domain” panel, and click “CONTINUE”.\n\n\n\nEnsure the selected record type is “TXT”, then copy the TXT record (“google-site-verification=…”).\n\n\n\n\n\n\nKeep the GCP tab open. Open Porkbun and click “DNS” for your domain (e.g., “everysinglecountry.com”).\n\n\n\nAdd a “TXT” record by pasting the value from Step 10 into the “Answer” field, then click “Add”.\n\n\n\nKeep the Porkbun tab open. Return to the GCP tab and click “VERIFY”.\n\n\n\nOnce ownership is confirmed, you’ll see the message “Ownership verified”.\n\n\n\nClick “REFRESH”.\n\n\n16.Click “CONTINUE”.\n\n\n\n\n\nIn the GCP tab, you’ll see the required DNS records listed. Copy each record one by one (starting with the “A” records).\n\n\n\nSwitch to the Porkbun tab. Before adding the new DNS records, remove any existing “ALIAS” and “CNAME” records by clicking the trashcan icon to the right of each entry.\n\n\n\nAdd the “A” records. For each record, select “A” as the “Type”, enter the corresponding IP address into the “Answer” field, and click “Add”.\n\n\n\nNext, add the “AAAA” records. Follow the same process, selecting “AAAA” as the “Type” and pasting the corresponding values from the GCP tab into the “Answer” field.\n\n\n\nIn this example, there are a total of 8 DNS records to add. After adding all the DNS records in Porkbun, your configuration should look similar to this:\n\n\n\nGo back to the GCP tab and click “DONE” to close the DNS records list. Now, you’ll need to wait for DNS propagation. This process can take a few minutes to several hours, depending on your domain registrar and internet service provider. In this example, it took one hour, but it can be shorter or longer.\n\n\n\nOnce the DNS propagation is complete, you’ll see a green checkmark next to your domain in the GCP Domain Mapping panel. This indicates that your custom domain is successfully linked to your Cloud Run service.\n\n\n\nCongratulations! Your Shiny app is now accessible at its new custom domain, providing a professional and branded experience for your users.\nEnjoy your new setup!"
  },
  {
    "objectID": "posts/assign-custom-domain/index.html#assign-a-custom-domain-to-a-google-cloud-run-service",
    "href": "posts/assign-custom-domain/index.html#assign-a-custom-domain-to-a-google-cloud-run-service",
    "title": "Assign a Custom Domain to a Google Cloud Run Service",
    "section": "",
    "text": "In this post, we’ll guide you through assigning a custom domain to a Google Cloud Run Service, such as the one we deployed in our previous post. Using Google Cloud Run’s Domain Mappings feature, we’ll map your Shiny app to a memorable domain name like “everysinglecountry.com”.\n\n\nBefore we begin, ensure that:\n\nYour Shiny app is deployed in one of the supported regions for Domain Mappings.\nYou have already purchased a domain. For this example, we bought “everysinglecountry.com” at Porkbun for $11.06/year. You can use any registrar as the steps are similar.\n\nLet’s get started!\n\n\n\n\n\nLog in to the Google Cloud console and open the Navigation menu (three horizontal lines icon).\n\n\n\nSelect “Cloud Run”.\n\n\n\nClick “MANAGE CUSTOM DOMAINS”.\n\n\n\nClick “ADD MAPPING”.\n\n\n\nSelect your service, such as “everysinglecountry”.\n\n\n\nClick “Cloud Run Domain Mappings”.\n\n\n\nEnter your domain name (e.g., “everysinglecountry.com”) and click “CONTINUE”.\n\n\n\nClick “VERIFY IN SEARCH CONSOLE” to validate ownership.\n\n\n\nEnter the domain name in the “Domain” panel, and click “CONTINUE”.\n\n\n\nEnsure the selected record type is “TXT”, then copy the TXT record (“google-site-verification=…”).\n\n\n\n\n\n\nKeep the GCP tab open. Open Porkbun and click “DNS” for your domain (e.g., “everysinglecountry.com”).\n\n\n\nAdd a “TXT” record by pasting the value from Step 10 into the “Answer” field, then click “Add”.\n\n\n\nKeep the Porkbun tab open. Return to the GCP tab and click “VERIFY”.\n\n\n\nOnce ownership is confirmed, you’ll see the message “Ownership verified”.\n\n\n\nClick “REFRESH”.\n\n\n16.Click “CONTINUE”.\n\n\n\n\n\nIn the GCP tab, you’ll see the required DNS records listed. Copy each record one by one (starting with the “A” records).\n\n\n\nSwitch to the Porkbun tab. Before adding the new DNS records, remove any existing “ALIAS” and “CNAME” records by clicking the trashcan icon to the right of each entry.\n\n\n\nAdd the “A” records. For each record, select “A” as the “Type”, enter the corresponding IP address into the “Answer” field, and click “Add”.\n\n\n\nNext, add the “AAAA” records. Follow the same process, selecting “AAAA” as the “Type” and pasting the corresponding values from the GCP tab into the “Answer” field.\n\n\n\nIn this example, there are a total of 8 DNS records to add. After adding all the DNS records in Porkbun, your configuration should look similar to this:\n\n\n\nGo back to the GCP tab and click “DONE” to close the DNS records list. Now, you’ll need to wait for DNS propagation. This process can take a few minutes to several hours, depending on your domain registrar and internet service provider. In this example, it took one hour, but it can be shorter or longer.\n\n\n\nOnce the DNS propagation is complete, you’ll see a green checkmark next to your domain in the GCP Domain Mapping panel. This indicates that your custom domain is successfully linked to your Cloud Run service.\n\n\n\nCongratulations! Your Shiny app is now accessible at its new custom domain, providing a professional and branded experience for your users.\nEnjoy your new setup!"
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html",
    "href": "posts/deploy-your-shiny-app/index.html",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "",
    "text": "In this blog post, we’ll guide you through deploying a Shiny app to production using Google Cloud Platform (GCP), leveraging services that are part of GCP’s free tier. Specifically, we’ll use Cloud Run and Artifact Registry, both of which offer generous free-tier allocations, allowing you to deploy and run your app at no cost, depending on your usage.\nFor this tutorial, we’ll use a simple dockerized Shiny app called everysinglecountry, which interacts with public APIs. This app doesn’t require a backend, database, or authentication, as we’ll cover these topics in future tutorials. If you’re interested in expanding your app with these features, stay tuned!\nBy the end of this tutorial, you’ll have your Shiny app running on GCP’s scalable infrastructure—completely within the free-tier limits.\n\n\nBefore we get started, ensure you have the following:\n\nAn active GCP account.\nThe gcloud command-line interface installed and configured.\nA dockerized Shiny app.\n\n\n\n\n\nEnable the “Artifact Registry API” and “Cloud Run” services.\nPush your Docker image to Google Artifact Registry.\nDeploy the image to Cloud Run for production."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html#deploy-your-shiny-app-on-google-cloud-platform",
    "href": "posts/deploy-your-shiny-app/index.html#deploy-your-shiny-app-on-google-cloud-platform",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "",
    "text": "In this blog post, we’ll guide you through deploying a Shiny app to production using Google Cloud Platform (GCP), leveraging services that are part of GCP’s free tier. Specifically, we’ll use Cloud Run and Artifact Registry, both of which offer generous free-tier allocations, allowing you to deploy and run your app at no cost, depending on your usage.\nFor this tutorial, we’ll use a simple dockerized Shiny app called everysinglecountry, which interacts with public APIs. This app doesn’t require a backend, database, or authentication, as we’ll cover these topics in future tutorials. If you’re interested in expanding your app with these features, stay tuned!\nBy the end of this tutorial, you’ll have your Shiny app running on GCP’s scalable infrastructure—completely within the free-tier limits.\n\n\nBefore we get started, ensure you have the following:\n\nAn active GCP account.\nThe gcloud command-line interface installed and configured.\nA dockerized Shiny app.\n\n\n\n\n\nEnable the “Artifact Registry API” and “Cloud Run” services.\nPush your Docker image to Google Artifact Registry.\nDeploy the image to Cloud Run for production."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html#lets-get-started",
    "href": "posts/deploy-your-shiny-app/index.html#lets-get-started",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "Let’s Get Started",
    "text": "Let’s Get Started\nOpen a terminal and navigate to the directory where your Shiny app is located:\n$ cd ~/Projects/everysinglecountry/\nEnsure that your Docker image is working as expected by running it locally. Visit http://localhost:8080 in your browser to test the app.\n$ docker run -p 8080:8080 everysinglecountry\nLog in to your GCP account using the following command. This will open a browser window where you must select the appropriate account for your project:\n$ gcloud auth login\n\nSelect your GCP account.\n\n\n\nClick “Continue”.\n\n\n\nClick “Allow” to grant the necessary permissions.\n\n\nInitialize the GCP account. Select the appropriate account and project (e.g., everysinglecountryproject@gmail.com and every-single-country respectively).\n$ gcloud init\nEnable the “Artifact Registry” service so you can push your Docker image:\n$ gcloud services enable artifactregistry.googleapis.com\nAuthenticate Docker to work with Google Artifact Registry:\n$ gcloud auth configure-docker\nTag your Docker image and push it to Artifact Registry:\n$ docker tag everysinglecountry gcr.io/every-single-country/everysinglecountry\n$ docker push gcr.io/every-single-country/everysinglecountry\nEnable the “Cloud Run” service to allow deployment of your Docker image:\n$ gcloud services enable run.googleapis.com\nNow, deploy the Docker image to Cloud Run. The --platform managed flag specifies that we’re using the fully managed version of Cloud Run. The --region us-central1 flag sets the region (I chose us-central1 because it works with Cloud Run Domain Mappings), and the --allow-unauthenticated flag makes the app accessible without authentication.\n$ gcloud run deploy everysinglecountry \\\n  --image gcr.io/every-single-country/everysinglecountry:latest \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated\nOnce the deployment is complete, Cloud Run will provide a “Service URL”. Open the URL in your browser to access your Shiny app, which is now publicly available.\n\nIn our example, you can test the deployed app at https://everysinglecountry-122108936732.us-central1.run.app/."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html#conclusion",
    "href": "posts/deploy-your-shiny-app/index.html#conclusion",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! You’ve successfully deployed your Shiny app on Google Cloud Platform using Cloud Run. In the next post, we’ll dive into deploying Shiny apps with backend functions via Plumber RESTful APIs and discuss integrating databases for dynamic app functionality."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Enable Google Cloud Platform Managed User Auth\n\n\n\n\n\n\nAuth\n\n\nGCP\n\n\nFree-Tier\n\n\n\n\n\n\n\n\n\nNov 26, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nAssign a Custom Domain to a Google Cloud Run Service\n\n\n\n\n\n\nDomain Names\n\n\nGCP\n\n\nFree-Tier\n\n\n\nLearn how to assign a custom domain to your Google Cloud Run Service for a professional and branded URL.\n\n\n\n\n\nNov 20, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy Your Shiny App on Google Cloud Platform\n\n\n\n\n\n\nShiny\n\n\nGCP\n\n\nFree-Tier\n\n\nDeployment\n\n\n\nA step-by-step guide to deploying a Shiny app on Google Cloud Platform using Artifact Registry and Cloud Run.\n\n\n\n\n\nNov 18, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nCreate Your Google Cloud Account\n\n\n\n\n\n\nGCP\n\n\nFree-Tier\n\n\nAccounts\n\n\n\nLearn how to set up your Google Cloud Platform account to deploy R code to production. Get $300 in free credits with this step-by-step guide.\n\n\n\n\n\nNov 13, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\nNo matching items"
  }
]
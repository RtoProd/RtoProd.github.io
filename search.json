[
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "At RtoProd.com, we bridge the gap between R development and full-scale production. We understand that taking R code from development to production-ready can be challenging - but possible. Our platform is dedicated to simplifying and accelerating this process by sharing proven insights, tools, and techniques to streamline deployment on modern infrastructure.\nOur team is composed of experts with diverse technical backgrounds, bringing together deep expertise in data science, software engineering, and DevOps. This blend of expertise allows us to tackle the unique demands of production environments, from creating robust data pipelines and APIs to deploying Shiny applications and scaling machine learning models.\nThrough our blog posts, tutorials, and resources, we aim to empower teams to harness the full potential of R in production settings. Whether you’re building an end-to-end data pipeline, deploying a machine learning model, or creating an interactive web app, RtoProd.com is here to guide you in making your code work seamlessly at scale.\nJoin us as we explore best practices, cloud-native technologies, and the latest advancements in R deployment to help you confidently transition your R code from prototype to production.\nWanna talk? Write to us at hello@RtoProd.com"
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html",
    "href": "posts/create-your-gcp-account/index.html",
    "title": "Create Your Google Cloud Account",
    "section": "",
    "text": "Welcome to the first blog post on RtoProd.com! Our mission is to provide tips, tricks, and insights to help you transition your R code to production-grade infrastructure.\nBefore diving into the technical aspects of deploying R applications, the very first thing we need is an account on a production-grade infrastructure platform. In this post, we’ll guide you through creating a Google Cloud Platform (GCP) account. GCP offers a robust and scalable environment perfect for hosting R applications, pipelines, and APIs. By following this tutorial, you’ll set up your account and gain access to $300 in free credits.\nIn addition to the free credits, GCP offers a range of free-tier services that you can use indefinitely under specified limits. You can find a complete list of free-tier services here."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#welcome-to-rtoprod.com",
    "href": "posts/create-your-gcp-account/index.html#welcome-to-rtoprod.com",
    "title": "Create Your Google Cloud Account",
    "section": "",
    "text": "Welcome to the first blog post on RtoProd.com! Our mission is to provide tips, tricks, and insights to help you transition your R code to production-grade infrastructure.\nBefore diving into the technical aspects of deploying R applications, the very first thing we need is an account on a production-grade infrastructure platform. In this post, we’ll guide you through creating a Google Cloud Platform (GCP) account. GCP offers a robust and scalable environment perfect for hosting R applications, pipelines, and APIs. By following this tutorial, you’ll set up your account and gain access to $300 in free credits.\nIn addition to the free credits, GCP offers a range of free-tier services that you can use indefinitely under specified limits. You can find a complete list of free-tier services here."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#why-choose-google-cloud",
    "href": "posts/create-your-gcp-account/index.html#why-choose-google-cloud",
    "title": "Create Your Google Cloud Account",
    "section": "Why Choose Google Cloud?",
    "text": "Why Choose Google Cloud?\nGoogle Cloud Platform is an excellent choice for deploying R projects due to its scalability, compatibility with R tools, and a wide range of services. While other cloud providers like AWS and Azure are equally viable, we focus on GCP because it’s what we’re most comfortable with. Other cloud service providers are as recommended as GCP, and most of the services and procedures remain similar.\nWe recommend creating a new account for each project. First, to keep projects encapsulated in their own account, making it easier to manage and organize resources. Second, because Google offers $300 in credits for every new account, providing a great opportunity to experiment with their services at no cost."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#step-by-step-guide-to-creating-a-google-cloud-account",
    "href": "posts/create-your-gcp-account/index.html#step-by-step-guide-to-creating-a-google-cloud-account",
    "title": "Create Your Google Cloud Account",
    "section": "Step-by-Step Guide to Creating a Google Cloud Account",
    "text": "Step-by-Step Guide to Creating a Google Cloud Account\nThis guide covers everything from signing up to completing the payment setup. Don’t worry—your payment method won’t be charged until your $300 free credits are either spent or expire in 90 days. Let’s get started!\n\nVisit https://cloud.google.com/.\nClick the “Start Free” button.\n\n\n\nClick “Create account”, then choose “For work or my business” (or another option that suits your needs).\n\n\n\nClick “Get a Gmail address”.\n\n\n\nEnter your First and Last names, and then click on “Next”.\n\n\n\nFill in your birthdate and Gender, and click on “Next”.\n\n\n\nClick “Get a Gmail address instead”.\n\n\n\nFill in your Username (we recommend a name related to the new project), and click “Next”.\n\n\n\nFill in your Password, and click “Next”.\n\n\n\nFill in your Phone number, and click “Next”. This step is safe; you won’t be charged anything to your phone number, and you can use your number for as many accounts as you need.\n\n\n\nEnter the verification code you receive via SMS, and click “Next”.\n\n\n\nAdd a Recovery email (we recommend using your most used email), and click “Next”.\n\n\n\nFill in your Phone number again, and click “Next”.\n\n\n\nIf a screen pops up stating that your phone number is already in use for another account, click “Continue creating a new account”.\n\n\n\nJust click “Skip”.\n\n\n\nClick “Next”.\n\n\n\nThoroughly read the terms and conditions, and click “I agree” (if you agree).\n\n\n\nClick “Not Now”.\n\n\n\nFill in your business country, and click “Agree & continue” (if you agree with the terms).\n\n\n\nClick “Start free”.\n\n\n\nFill in your payments profile. Here, we use the “Individual” profile type.\n\n\n\nClick “Start free”.\n\n\n\nFill in your payment method details. Here, we’ve used a credit card.\n\n\n\nAdd your credit card information. It won’t be charged until your free credits expire, at which point you can decide whether to continue paying or disable non-free-tier services.\n\n\n\nClick “Start free”.\n\n\n\nClick “Done”.\n\n\n\nThat’s it! Your account is now ready to use, with free-tier services enabled, and you’ve got $300 in credits to use within the next 3 months."
  },
  {
    "objectID": "posts/create-your-gcp-account/index.html#creating-your-first-project-optional",
    "href": "posts/create-your-gcp-account/index.html#creating-your-first-project-optional",
    "title": "Create Your Google Cloud Account",
    "section": "Creating Your First Project (Optional)",
    "text": "Creating Your First Project (Optional)\nWhile it’s perfectly fine to start with the default “My First Project” assigned by Google Cloud, creating a dedicated project for each of your R deployments helps you organize resources more effectively. It’s a simple process and a great habit to adopt.\n\nVisualCommand Line\n\n\n\nClick on “My First Project”.\n\n\n\nClick “NEW PROJECT”.\n\n\n\nEnter the new “Project name”, and then click “CREATE”.\n\n\n\nWait a few moments for the new project to be created. Once the green checkmark appears, click “SELECT PROJECT” to start using your new project.\n\n\n\n\n# Authenticate gcloud with your created account.\n$ gcloud auth login # This will open your browser. Log in with your GCP account credentials.\nYou are now logged in as [everysinglecountryproject@gmail.com].\n\n# Create a new Google Cloud project.\n$ gcloud projects create everysinglecountry --name=\"Every Single Country\"\nCreate in progress for [https://cloudresourcemanager.googleapis.com/v1/projects/everysinglecountry].\nWaiting for [operations/cp.5754965963896291291] to finish...done.\nEnabling service [cloudapis.googleapis.com] on project [everysinglecountry]...\nOperation \"operations/acat.p2-974569654945-863216b7-3654-42da-b2d5-f3eb61c369aa\" finished successfully.\n\n# Set the new project as the default project for gcloud.\n$ gcloud config set project everysinglecountry\nUpdated property [core/project].\n\n# Set a billing account for this project.\n# List the billing accounts information.\n$ gcloud billing accounts list\n\nACCOUNT_ID            NAME                OPEN  MASTER_ACCOUNT_ID\n012345-678901-234567  My Billing Account  True\n\n# Set the billing account.\n$ gcloud billing projects link everysinglecountry --billing-account=012345-678901-234567\nbillingAccountName: billingAccounts/012345-678901-234567\nbillingEnabled: true\nname: projects/everysinglecountry/billingInfo\nprojectId: everysinglecountry"
  },
  {
    "objectID": "posts/enable-cloud-sql-database/index.html",
    "href": "posts/enable-cloud-sql-database/index.html",
    "title": "Enable Cloud SQL Database",
    "section": "",
    "text": "This guide outlines the steps to enable and configure a Cloud SQL instance in Google Cloud Platform (GCP). We will create a PostgreSQL database, configure access, and connect using R.\nNote: The database we are creating will not be publicly accessible for security reasons. It can only be accessed through the Google Cloud environment or via secure connections like the Cloud SQL Proxy.\n\n\nBefore starting, ensure you have:\n\nAn active GCP account.\nThe gcloud command-line interface installed and configured.\n\nLet’s get started!\n\n\nVisualCommand Line\n\n\n\nLog in to the Google Cloud console and open the Navigation menu (three horizontal lines icon).\n\n\n\nSelect “SQL”.\n\n\n\nClick “CREATE INSTANCE WITH YOUR FREE CREDITS”.\n\n\n\nClick “Choose PostgreSQL”, unless you prefer another database engine.\n\n\n\nClick “ENABLE API”.\n\n\n\nChoose your desired SQL edition. As we are working on a simple project, we select “Enterprise” in this example.\n\n\n\nChoose your desired SQL Virtual Machine (VM). For this example we are going to select the smallest edition preset, the Sandbox VM (2 vCPU, 8 GB RAM, 10 GB Storage, and single zone). These settings can be changed later.\n\n\n\nSpecify the “Database version” (PostgreSQL 16 in this example), fill in an “Instance ID”, and set an admin “Password” for the “postgres” user.\n\n\n\nSelect the instance “Region” and “Zonal availability”. For this example, “us-central1” (as is the same as we used in the previous posts), and “Single zone” as this app is a small project (not widely used yet, we can change this in the future).\n\n\n\nReview the instance settings summary.\n\n\n\nTake a look at the “Pricing estimate”.\n\n\n\nClick “CREATE INSTANCE”.\n\n\n\nWait for the instance creation to complete.\n\n\n\nOnce the green checkmark appears, your instance is ready.\n\n\n\nNow, let’s create our first database in the newly created instance. Click “Databases”.\n\n\n\nClick “CREATE DATABASE”.\n\n\n\nSet the “Database Name” and click “CREATE”.\n\n\n\nVerify the new database is listed.\n\n\n\nNow, let’s create a new user for the database. Click “Users”.\n\n\n\nClick “ADD USER ACCOUNT”.\n\n\n\nFill in the new “User name” and “Password”, and click “ADD”.\n\n\n\nVerify the new user was created.\n\n\n\nNow, let’s create our first table in the database. Click “Cloud SQL Studio”.\n\n\n\nLogin to the database using the “User” and “Password” you created in step 21.\n\n\n\nOpen an “Editor” tab.\n\n\n\nRun SQL commands to create your desired tables.\n\n\n\nNow, in order to be able to access the database from outside GCP, we will need to get the JSON keys for a GCP Service Account. In GCP’s “Search” panel, type “Service Accounts”, and click on that service. If you don’t have a service account to use, create a new one, by clicking on “CREATE SERVICE ACCOUNT”.\n\n\n\nCreate the JSON keys for the service account. Click on the “Actions” (three dots).\n\n\n\nClick “Manage keys”.\n\n\n\nClick “ADD KEY” and then “Create new key”.\n\n\n\nCheck “JSON” and click “CREATE”. After creation, the JSON key will be downloaded by your browser, move this key file to ~/.gcp/, e.g., $ mv ~/Downloads/every-single-country-b2e753a1eee3.json ~/.gcp/everysinglecountry-sa-key.json.\n\n\n\nNow, to be able to access the database locally, we will use the cloud-sql-proxy command, for that we need to enable the “Cloud SQL Admin API”. In GCP’s “Search” panel, type “Cloud SQL Admin API”, and click on that service.\n\n\n\nEnable the “Cloud SQL Admin API” service by clicking “ENABLE”.\n\n\n\n\n\nList the available projects.\n\n$ gcloud projects list\nPROJECT_ID              NAME                  PROJECT_NUMBER\nevery-single-country    Every Single Country  122108936732\n\nSet the active project, in case it wasn’t already set.\n\n$ gcloud config set project every-single-country\nUpdated property [core/project].\n\nEnable the Cloud SQL Admin API, to be able to use the cloud-sql-proxy command.\n\n$ gcloud services enable sqladmin.googleapis.com\nOperation \"operations/acat.p2-974569654945-b833df22-17ed-4724-8615-b9c271849917\" finished successfully.\n\nCreate a Cloud SQL instance.\n\n$ gcloud sql instances create everysinglecountry \\\n  --database-version=POSTGRES_16 \\\n  --tier=db-custom-2-8192 \\\n  --region=us-central1 \\\n  --storage-size=10GB \\\n  --edition=ENTERPRISE \\\n  --backup \\\n  --enable-point-in-time-recovery\nCreating Cloud SQL instance for POSTGRES_16...done.\nCreated [https://sqladmin.googleapis.com/sql/v1beta4/projects/every-single-country/instances/everysinglecountry].\nNAME                DATABASE_VERSION  LOCATION       TIER              PRIMARY_ADDRESS  PRIVATE_ADDRESS  STATUS\neverysinglecountry  POSTGRES_16       us-central1-b  db-custom-2-8192  34.136.96.114    -                RUNNABLE\n\nCreate a database in the instance.\n\n$ gcloud sql databases create everysinglecountry --instance=everysinglecountry\nCreating Cloud SQL database...done.\nCreated database [everysinglecountry].\ninstance: everysinglecountry\nname: everysinglecountry\nproject: every-single-country\n\nCreate a new user for the database.\n\n$ gcloud sql users create everysinglecountry \\\n  --instance=everysinglecountry \\\n  --password=YOUR_DB_PASSWORD\nCreating Cloud SQL user...done.\nCreated user [everysinglecountry].\n\nCreate a service account to be used by cloud-sql-proxy.\n\n$ gcloud iam service-accounts create everysinglecountry-sa \\\n  --description=\"EverySingleCountry Service Account\" \\\n  --display-name=\"everysinglecountry-sa\"\nCreated service account [everysinglecountry-sa].\n\nAssign needed IAM Policy Bindings to the service account.\n\n$ gcloud projects add-iam-policy-binding every-single-country \\\n  --member=\"serviceAccount:everysinglecountry-sa@every-single-country.iam.gserviceaccount.com\" \\\n  --role=\"roles/cloudsql.client\"\nUpdated IAM policy for project [every-single-country].\nbindings:\n- members:\n  - serviceAccount:everysinglecountry-sa@every-single-country.iam.gserviceaccount.com\n  role: roles/cloudsql.client\n- members:\n  - serviceAccount:firebase-service-account@firebase-sa-management.iam.gserviceaccount.com\n  - serviceAccount:service-974569654945@gcp-sa-firebase.iam.gserviceaccount.com\n  role: roles/firebase.managementServiceAgent\n- members:\n  - serviceAccount:firebase-adminsdk-efpkq@every-single-country.iam.gserviceaccount.com\n  role: roles/firebase.sdkAdminServiceAgent\n- members:\n  - serviceAccount:firebase-adminsdk-efpkq@every-single-country.iam.gserviceaccount.com\n  role: roles/iam.serviceAccountTokenCreator\n- members:\n  - user:everysinglecountryproject@gmail.com\n  role: roles/owner\netag: BwYo24Y3_jQ=\nversion: 1\n\nGenerate a JSON key for the service account .\n\n$ gcloud iam service-accounts keys create ~/.gcp/everysinglecountry-sa-key.json --iam-account=everysinglecountry-sa@every-single-country.iam.gserviceaccount.com\ncreated key [6b71b4f4895ead65646249bf76c05093467669bf] of type [json] as [/Users/jcrodriguez/.gcp/everysinglecountry-sa-key.json] for [everysinglecountry-sa@every-single-country.iam.gserviceaccount.com]"
  },
  {
    "objectID": "posts/enable-cloud-sql-database/index.html#enable-cloud-sql-database",
    "href": "posts/enable-cloud-sql-database/index.html#enable-cloud-sql-database",
    "title": "Enable Cloud SQL Database",
    "section": "",
    "text": "This guide outlines the steps to enable and configure a Cloud SQL instance in Google Cloud Platform (GCP). We will create a PostgreSQL database, configure access, and connect using R.\nNote: The database we are creating will not be publicly accessible for security reasons. It can only be accessed through the Google Cloud environment or via secure connections like the Cloud SQL Proxy.\n\n\nBefore starting, ensure you have:\n\nAn active GCP account.\nThe gcloud command-line interface installed and configured.\n\nLet’s get started!\n\n\nVisualCommand Line\n\n\n\nLog in to the Google Cloud console and open the Navigation menu (three horizontal lines icon).\n\n\n\nSelect “SQL”.\n\n\n\nClick “CREATE INSTANCE WITH YOUR FREE CREDITS”.\n\n\n\nClick “Choose PostgreSQL”, unless you prefer another database engine.\n\n\n\nClick “ENABLE API”.\n\n\n\nChoose your desired SQL edition. As we are working on a simple project, we select “Enterprise” in this example.\n\n\n\nChoose your desired SQL Virtual Machine (VM). For this example we are going to select the smallest edition preset, the Sandbox VM (2 vCPU, 8 GB RAM, 10 GB Storage, and single zone). These settings can be changed later.\n\n\n\nSpecify the “Database version” (PostgreSQL 16 in this example), fill in an “Instance ID”, and set an admin “Password” for the “postgres” user.\n\n\n\nSelect the instance “Region” and “Zonal availability”. For this example, “us-central1” (as is the same as we used in the previous posts), and “Single zone” as this app is a small project (not widely used yet, we can change this in the future).\n\n\n\nReview the instance settings summary.\n\n\n\nTake a look at the “Pricing estimate”.\n\n\n\nClick “CREATE INSTANCE”.\n\n\n\nWait for the instance creation to complete.\n\n\n\nOnce the green checkmark appears, your instance is ready.\n\n\n\nNow, let’s create our first database in the newly created instance. Click “Databases”.\n\n\n\nClick “CREATE DATABASE”.\n\n\n\nSet the “Database Name” and click “CREATE”.\n\n\n\nVerify the new database is listed.\n\n\n\nNow, let’s create a new user for the database. Click “Users”.\n\n\n\nClick “ADD USER ACCOUNT”.\n\n\n\nFill in the new “User name” and “Password”, and click “ADD”.\n\n\n\nVerify the new user was created.\n\n\n\nNow, let’s create our first table in the database. Click “Cloud SQL Studio”.\n\n\n\nLogin to the database using the “User” and “Password” you created in step 21.\n\n\n\nOpen an “Editor” tab.\n\n\n\nRun SQL commands to create your desired tables.\n\n\n\nNow, in order to be able to access the database from outside GCP, we will need to get the JSON keys for a GCP Service Account. In GCP’s “Search” panel, type “Service Accounts”, and click on that service. If you don’t have a service account to use, create a new one, by clicking on “CREATE SERVICE ACCOUNT”.\n\n\n\nCreate the JSON keys for the service account. Click on the “Actions” (three dots).\n\n\n\nClick “Manage keys”.\n\n\n\nClick “ADD KEY” and then “Create new key”.\n\n\n\nCheck “JSON” and click “CREATE”. After creation, the JSON key will be downloaded by your browser, move this key file to ~/.gcp/, e.g., $ mv ~/Downloads/every-single-country-b2e753a1eee3.json ~/.gcp/everysinglecountry-sa-key.json.\n\n\n\nNow, to be able to access the database locally, we will use the cloud-sql-proxy command, for that we need to enable the “Cloud SQL Admin API”. In GCP’s “Search” panel, type “Cloud SQL Admin API”, and click on that service.\n\n\n\nEnable the “Cloud SQL Admin API” service by clicking “ENABLE”.\n\n\n\n\n\nList the available projects.\n\n$ gcloud projects list\nPROJECT_ID              NAME                  PROJECT_NUMBER\nevery-single-country    Every Single Country  122108936732\n\nSet the active project, in case it wasn’t already set.\n\n$ gcloud config set project every-single-country\nUpdated property [core/project].\n\nEnable the Cloud SQL Admin API, to be able to use the cloud-sql-proxy command.\n\n$ gcloud services enable sqladmin.googleapis.com\nOperation \"operations/acat.p2-974569654945-b833df22-17ed-4724-8615-b9c271849917\" finished successfully.\n\nCreate a Cloud SQL instance.\n\n$ gcloud sql instances create everysinglecountry \\\n  --database-version=POSTGRES_16 \\\n  --tier=db-custom-2-8192 \\\n  --region=us-central1 \\\n  --storage-size=10GB \\\n  --edition=ENTERPRISE \\\n  --backup \\\n  --enable-point-in-time-recovery\nCreating Cloud SQL instance for POSTGRES_16...done.\nCreated [https://sqladmin.googleapis.com/sql/v1beta4/projects/every-single-country/instances/everysinglecountry].\nNAME                DATABASE_VERSION  LOCATION       TIER              PRIMARY_ADDRESS  PRIVATE_ADDRESS  STATUS\neverysinglecountry  POSTGRES_16       us-central1-b  db-custom-2-8192  34.136.96.114    -                RUNNABLE\n\nCreate a database in the instance.\n\n$ gcloud sql databases create everysinglecountry --instance=everysinglecountry\nCreating Cloud SQL database...done.\nCreated database [everysinglecountry].\ninstance: everysinglecountry\nname: everysinglecountry\nproject: every-single-country\n\nCreate a new user for the database.\n\n$ gcloud sql users create everysinglecountry \\\n  --instance=everysinglecountry \\\n  --password=YOUR_DB_PASSWORD\nCreating Cloud SQL user...done.\nCreated user [everysinglecountry].\n\nCreate a service account to be used by cloud-sql-proxy.\n\n$ gcloud iam service-accounts create everysinglecountry-sa \\\n  --description=\"EverySingleCountry Service Account\" \\\n  --display-name=\"everysinglecountry-sa\"\nCreated service account [everysinglecountry-sa].\n\nAssign needed IAM Policy Bindings to the service account.\n\n$ gcloud projects add-iam-policy-binding every-single-country \\\n  --member=\"serviceAccount:everysinglecountry-sa@every-single-country.iam.gserviceaccount.com\" \\\n  --role=\"roles/cloudsql.client\"\nUpdated IAM policy for project [every-single-country].\nbindings:\n- members:\n  - serviceAccount:everysinglecountry-sa@every-single-country.iam.gserviceaccount.com\n  role: roles/cloudsql.client\n- members:\n  - serviceAccount:firebase-service-account@firebase-sa-management.iam.gserviceaccount.com\n  - serviceAccount:service-974569654945@gcp-sa-firebase.iam.gserviceaccount.com\n  role: roles/firebase.managementServiceAgent\n- members:\n  - serviceAccount:firebase-adminsdk-efpkq@every-single-country.iam.gserviceaccount.com\n  role: roles/firebase.sdkAdminServiceAgent\n- members:\n  - serviceAccount:firebase-adminsdk-efpkq@every-single-country.iam.gserviceaccount.com\n  role: roles/iam.serviceAccountTokenCreator\n- members:\n  - user:everysinglecountryproject@gmail.com\n  role: roles/owner\netag: BwYo24Y3_jQ=\nversion: 1\n\nGenerate a JSON key for the service account .\n\n$ gcloud iam service-accounts keys create ~/.gcp/everysinglecountry-sa-key.json --iam-account=everysinglecountry-sa@every-single-country.iam.gserviceaccount.com\ncreated key [6b71b4f4895ead65646249bf76c05093467669bf] of type [json] as [/Users/jcrodriguez/.gcp/everysinglecountry-sa-key.json] for [everysinglecountry-sa@every-single-country.iam.gserviceaccount.com]"
  },
  {
    "objectID": "posts/enable-cloud-sql-database/index.html#connect-locally-to-the-database",
    "href": "posts/enable-cloud-sql-database/index.html#connect-locally-to-the-database",
    "title": "Enable Cloud SQL Database",
    "section": "Connect Locally to the Database",
    "text": "Connect Locally to the Database\nThe Cloud SQL database we just created is not publicly accessible and can only be reached within the GCP environment. To connect to your database locally, follow these steps:\n\nGet the instance’s connection name.\n\n# Get the connection name of the Cloud SQL instance.\n$ gcloud sql instances describe everysinglecountry --format=\"get(connectionName)\"\nevery-single-country:us-central1:everysinglecountry\n\nSetup a tunnel to access locally the database, using a Cloud SQL Proxy.\n\n# Use Cloud SQL Proxy to create a secure connection to the database.\n$ cloud-sql-proxy every-single-country:us-central1:everysinglecountry --credentials-file=/Users/jcrodriguez/.gcp/everysinglecountry-sa-key.json \n2024/12/26 16:49:19 Authorizing with the credentials file at \"/Users/jcrodriguez/.gcp/everysinglecountry-sa-key.json\"\n2024/12/26 16:49:21 [every-single-country:us-central1:everysinglecountry] Listening on 127.0.0.1:5432\n2024/12/26 16:49:21 The proxy has started successfully and is ready for new connections!\nAt this point, the Cloud SQL Proxy is listening on localhost:5432, and you’re ready to connect to your database.\n\nConnect to the database in R.\n\nNow that the proxy is set up, you can connect to your database locally from R using the {DBI} package and the appropriate PostgreSQL driver. Here’s an example connection:\ncn &lt;- DBI::dbConnect(\n  drv = RPostgres::Postgres(),\n  dbname = \"everysinglecountry\",\n  host = \"localhost\",\n  user = \"everysinglecountry\",\n  password = \"YOUR_DB_PASSWORD\",\n  port = 5432\n)\nDBI::dbListTables(cn)\nDBI::dbDisconnect(cn)"
  },
  {
    "objectID": "posts/enable-cloud-sql-database/index.html#enable-cloud-sql-access-for-your-shiny-app",
    "href": "posts/enable-cloud-sql-database/index.html#enable-cloud-sql-access-for-your-shiny-app",
    "title": "Enable Cloud SQL Database",
    "section": "Enable Cloud SQL Access for your Shiny App",
    "text": "Enable Cloud SQL Access for your Shiny App\nIf you have deployed your Shiny app on a GCP Cloud Run service, as demonstrated in our blog post Deploy Your Shiny App on Google Cloud Platform, you need to grant it access to your Cloud SQL database. To do this, add the --add-cloudsql-instances flag to your deployment script:\n--add-cloudsql-instances=every-single-country:us-central1:everysinglecountry\nThe updated deployment command should look like this:\n$ gcloud run deploy everysinglecountry \\\n  --image gcr.io/every-single-country/everysinglecountry:latest \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated \\\n  --add-cloudsql-instances=every-single-country:us-central1:everysinglecountry\nThis configuration allows your app to connect “locally” to the database via the Cloud SQL instance. For details on connecting to the database locally, refer to the previous section."
  },
  {
    "objectID": "posts/enable-cloud-sql-database/index.html#conclusion",
    "href": "posts/enable-cloud-sql-database/index.html#conclusion",
    "title": "Enable Cloud SQL Database",
    "section": "Conclusion",
    "text": "Conclusion\nEnabling and configuring a Cloud SQL database in Google Cloud Platform is a straightforward process that provides a robust and secure environment for your data. By following this guide, you’ve set up a PostgreSQL instance, created a database, added users, and connected to it locally using the Cloud SQL Proxy. These steps ensure that your database is accessible only through secure methods, enhancing both performance and security.\nAs you deploy your applications, such as Shiny apps, you can seamlessly integrate them with your Cloud SQL database to manage and analyze data efficiently. GCP’s powerful tools and scalability options make it an ideal platform for hosting and managing your databases."
  },
  {
    "objectID": "posts/enable-google-analytics/index.html",
    "href": "posts/enable-google-analytics/index.html",
    "title": "Enable Google Analytics for Your Shiny App",
    "section": "",
    "text": "Understanding how users interact with your Shiny app is key to improving its performance and user experience. Google Analytics provides powerful tools to track app usage, identify popular features, and gain actionable insights. Best of all, it’s free to get started.\nIn this guide, we’ll walk you through the process of integrating Google Analytics with your Shiny app, step by step.\n\n\n\n\nVisit Google Analytics, and click “Start measuring”.\n\n\n\nFill in your “Account details”, agree to the terms, and click “Next”.\n\n\n\n\n\n\nEnter your “Property details”, such as your app name and time zone, then click “Next”.\n\n\n\nProvide your “Business details”, and click “Next”.\n\n\n\nSelect your business objectives (e.g., measure user engagement), and click “Create”.\n\n\n\nAccept the terms of service to proceed, and click “I Accept”.\n\n\n\n\n\n\nSelect the “Web” platform.\n\n\n\nEnter the public “Website URL” of your Shiny app, give a “Stream name”, and click “Create & continue”.\n\n\n\nCopy the Google Analytics ID generated for your app (e.g., G-ABCD12E34F).\n\n\n\n\n\nTo connect your Shiny app to Google Analytics:\n\nInclude the Google Analytics gtag code in your app’s UI. To simplify this, use the pre-written R function from this gist. Copy the use_google_analytics function definition in your code, or directly source the gist:\n\nsource(paste0(\n  \"https://gist.githubusercontent.com/jcrodriguez1989/a6a9c4168262e99ef2f9c70a110886ab/raw/\",\n  \"ea6b48e1cdaaed2839524ad700a930f6d17583d2/ga_setup.R\"\n))\n\nUpdate your Shiny app’s UI code, it should look smimilar as shown below:\n\nui &lt;- fluidPage(\n  use_google_analytics(\"G-ABCD12E34F\"),\n  ...\n\nRe-deploy your app to your hosting platform.\n\n\n\n\n\nReturn to the Google Analytics dashboard and click “Test installation”.\n\n\n\nIf everything is set up correctly, you’ll see a success message confirming that Google Analytics is tracking your app.\n\n\n\n\n\n\nWait a few hours for data collection to begin. Then, use the Google Analytics dashboard to explore user interactions, track app performance, and gain insights into how users engage with your app."
  },
  {
    "objectID": "posts/enable-google-analytics/index.html#why-add-google-analytics-to-your-shiny-app",
    "href": "posts/enable-google-analytics/index.html#why-add-google-analytics-to-your-shiny-app",
    "title": "Enable Google Analytics for Your Shiny App",
    "section": "",
    "text": "Understanding how users interact with your Shiny app is key to improving its performance and user experience. Google Analytics provides powerful tools to track app usage, identify popular features, and gain actionable insights. Best of all, it’s free to get started.\nIn this guide, we’ll walk you through the process of integrating Google Analytics with your Shiny app, step by step.\n\n\n\n\nVisit Google Analytics, and click “Start measuring”.\n\n\n\nFill in your “Account details”, agree to the terms, and click “Next”.\n\n\n\n\n\n\nEnter your “Property details”, such as your app name and time zone, then click “Next”.\n\n\n\nProvide your “Business details”, and click “Next”.\n\n\n\nSelect your business objectives (e.g., measure user engagement), and click “Create”.\n\n\n\nAccept the terms of service to proceed, and click “I Accept”.\n\n\n\n\n\n\nSelect the “Web” platform.\n\n\n\nEnter the public “Website URL” of your Shiny app, give a “Stream name”, and click “Create & continue”.\n\n\n\nCopy the Google Analytics ID generated for your app (e.g., G-ABCD12E34F).\n\n\n\n\n\nTo connect your Shiny app to Google Analytics:\n\nInclude the Google Analytics gtag code in your app’s UI. To simplify this, use the pre-written R function from this gist. Copy the use_google_analytics function definition in your code, or directly source the gist:\n\nsource(paste0(\n  \"https://gist.githubusercontent.com/jcrodriguez1989/a6a9c4168262e99ef2f9c70a110886ab/raw/\",\n  \"ea6b48e1cdaaed2839524ad700a930f6d17583d2/ga_setup.R\"\n))\n\nUpdate your Shiny app’s UI code, it should look smimilar as shown below:\n\nui &lt;- fluidPage(\n  use_google_analytics(\"G-ABCD12E34F\"),\n  ...\n\nRe-deploy your app to your hosting platform.\n\n\n\n\n\nReturn to the Google Analytics dashboard and click “Test installation”.\n\n\n\nIf everything is set up correctly, you’ll see a success message confirming that Google Analytics is tracking your app.\n\n\n\n\n\n\nWait a few hours for data collection to begin. Then, use the Google Analytics dashboard to explore user interactions, track app performance, and gain insights into how users engage with your app."
  },
  {
    "objectID": "posts/enable-google-analytics/index.html#congratulations",
    "href": "posts/enable-google-analytics/index.html#congratulations",
    "title": "Enable Google Analytics for Your Shiny App",
    "section": "Congratulations!",
    "text": "Congratulations!\nYou’ve successfully integrated Google Analytics into your Shiny app. With this setup, you can make data-driven decisions to improve your app and deliver a better experience for your users.\nLet me know in the comments if you have any questions or need further assistance."
  },
  {
    "objectID": "posts/assign-custom-domain/index.html",
    "href": "posts/assign-custom-domain/index.html",
    "title": "Assign a Custom Domain to a Google Cloud Run Service",
    "section": "",
    "text": "In this post, we’ll guide you through assigning a custom domain to a Google Cloud Run Service, such as the one we deployed in our previous post. Using Google Cloud Run’s Domain Mappings feature, we’ll map your Shiny app to a memorable domain name like “everysinglecountry.com”.\n\n\nBefore we begin, ensure that:\n\nYour Shiny app is deployed in one of the supported regions for Domain Mappings.\nYou have already purchased a domain. For this example, we bought “everysinglecountry.com” at Porkbun for $11.06/year. You can use any registrar as the steps are similar.\n\nLet’s get started!\n\n\n\n\n\nLog in to the Google Cloud console and open the Navigation menu (three horizontal lines icon).\n\n\n\nSelect “Cloud Run”.\n\n\n\nClick “MANAGE CUSTOM DOMAINS”.\n\n\n\nClick “ADD MAPPING”.\n\n\n\nSelect your service, such as “everysinglecountry”.\n\n\n\nClick “Cloud Run Domain Mappings”.\n\n\n\nEnter your domain name (e.g., “everysinglecountry.com”) and click “CONTINUE”.\n\n\n\nClick “VERIFY IN SEARCH CONSOLE” to validate ownership.\n\n\n\nEnter the domain name in the “Domain” panel, and click “CONTINUE”.\n\n\n\nEnsure the selected record type is “TXT”, then copy the TXT record (“google-site-verification=…”).\n\n\n\n\n\n\nKeep the GCP tab open. Open Porkbun and click “DNS” for your domain (e.g., “everysinglecountry.com”).\n\n\n\nAdd a “TXT” record by pasting the value from Step 10 into the “Answer” field, then click “Add”.\n\n\n\nKeep the Porkbun tab open. Return to the GCP tab and click “VERIFY”.\n\n\n\nOnce ownership is confirmed, you’ll see the message “Ownership verified”.\n\n\n\nClick “REFRESH”.\n\n\n16.Click “CONTINUE”.\n\n\n\n\n\nIn the GCP tab, you’ll see the required DNS records listed. Copy each record one by one (starting with the “A” records).\n\n\n\nSwitch to the Porkbun tab. Before adding the new DNS records, remove any existing “ALIAS” and “CNAME” records by clicking the trashcan icon to the right of each entry.\n\n\n\nAdd the “A” records. For each record, select “A” as the “Type”, enter the corresponding IP address into the “Answer” field, and click “Add”.\n\n\n\nNext, add the “AAAA” records. Follow the same process, selecting “AAAA” as the “Type” and pasting the corresponding values from the GCP tab into the “Answer” field.\n\n\n\nIn this example, there are a total of 8 DNS records to add. After adding all the DNS records in Porkbun, your configuration should look similar to this:\n\n\n\nGo back to the GCP tab and click “DONE” to close the DNS records list. Now, you’ll need to wait for DNS propagation. This process can take a few minutes to several hours, depending on your domain registrar and internet service provider. In this example, it took one hour, but it can be shorter or longer.\n\n\n\nOnce the DNS propagation is complete, you’ll see a green checkmark next to your domain in the GCP Domain Mapping panel. This indicates that your custom domain is successfully linked to your Cloud Run service.\n\n\n\nCongratulations! Your Shiny app is now accessible at its new custom domain, providing a professional and branded experience for your users.\nEnjoy your new setup!"
  },
  {
    "objectID": "posts/assign-custom-domain/index.html#assign-a-custom-domain-to-a-google-cloud-run-service",
    "href": "posts/assign-custom-domain/index.html#assign-a-custom-domain-to-a-google-cloud-run-service",
    "title": "Assign a Custom Domain to a Google Cloud Run Service",
    "section": "",
    "text": "In this post, we’ll guide you through assigning a custom domain to a Google Cloud Run Service, such as the one we deployed in our previous post. Using Google Cloud Run’s Domain Mappings feature, we’ll map your Shiny app to a memorable domain name like “everysinglecountry.com”.\n\n\nBefore we begin, ensure that:\n\nYour Shiny app is deployed in one of the supported regions for Domain Mappings.\nYou have already purchased a domain. For this example, we bought “everysinglecountry.com” at Porkbun for $11.06/year. You can use any registrar as the steps are similar.\n\nLet’s get started!\n\n\n\n\n\nLog in to the Google Cloud console and open the Navigation menu (three horizontal lines icon).\n\n\n\nSelect “Cloud Run”.\n\n\n\nClick “MANAGE CUSTOM DOMAINS”.\n\n\n\nClick “ADD MAPPING”.\n\n\n\nSelect your service, such as “everysinglecountry”.\n\n\n\nClick “Cloud Run Domain Mappings”.\n\n\n\nEnter your domain name (e.g., “everysinglecountry.com”) and click “CONTINUE”.\n\n\n\nClick “VERIFY IN SEARCH CONSOLE” to validate ownership.\n\n\n\nEnter the domain name in the “Domain” panel, and click “CONTINUE”.\n\n\n\nEnsure the selected record type is “TXT”, then copy the TXT record (“google-site-verification=…”).\n\n\n\n\n\n\nKeep the GCP tab open. Open Porkbun and click “DNS” for your domain (e.g., “everysinglecountry.com”).\n\n\n\nAdd a “TXT” record by pasting the value from Step 10 into the “Answer” field, then click “Add”.\n\n\n\nKeep the Porkbun tab open. Return to the GCP tab and click “VERIFY”.\n\n\n\nOnce ownership is confirmed, you’ll see the message “Ownership verified”.\n\n\n\nClick “REFRESH”.\n\n\n16.Click “CONTINUE”.\n\n\n\n\n\nIn the GCP tab, you’ll see the required DNS records listed. Copy each record one by one (starting with the “A” records).\n\n\n\nSwitch to the Porkbun tab. Before adding the new DNS records, remove any existing “ALIAS” and “CNAME” records by clicking the trashcan icon to the right of each entry.\n\n\n\nAdd the “A” records. For each record, select “A” as the “Type”, enter the corresponding IP address into the “Answer” field, and click “Add”.\n\n\n\nNext, add the “AAAA” records. Follow the same process, selecting “AAAA” as the “Type” and pasting the corresponding values from the GCP tab into the “Answer” field.\n\n\n\nIn this example, there are a total of 8 DNS records to add. After adding all the DNS records in Porkbun, your configuration should look similar to this:\n\n\n\nGo back to the GCP tab and click “DONE” to close the DNS records list. Now, you’ll need to wait for DNS propagation. This process can take a few minutes to several hours, depending on your domain registrar and internet service provider. In this example, it took one hour, but it can be shorter or longer.\n\n\n\nOnce the DNS propagation is complete, you’ll see a green checkmark next to your domain in the GCP Domain Mapping panel. This indicates that your custom domain is successfully linked to your Cloud Run service.\n\n\n\nCongratulations! Your Shiny app is now accessible at its new custom domain, providing a professional and branded experience for your users.\nEnjoy your new setup!"
  },
  {
    "objectID": "posts/add-user-auth/index.html",
    "href": "posts/add-user-auth/index.html",
    "title": "Enable Google Cloud Platform Managed User Auth",
    "section": "",
    "text": "In this post, we’ll walk through the process of enabling and configuring Google Cloud Platform’s (GCP) Identity Provider for R projects. Authentication and user management are critical for building secure and scalable applications. While it’s possible to implement your own authentication methods, doing so can introduce vulnerabilities, increase development time, and require ongoing maintenance to address security risks and compliance.\nGCP’s Identity Provider simplifies authentication workflows, offering a robust, managed solution that handles the heavy lifting for you. Whether you’re deploying Shiny apps, APIs, or R scripts on GCP, integrating a managed authentication service ensures ease of use, enhanced security, and scalability.\nThis guide provides a step-by-step approach to help you get started, leveraging GCP’s free-tier features wherever possible.\nLet’s dive in and set up secure user authentication for your R projects!\n\n\n\nThe email/password provider is the simplest authentication method to configure, making it an excellent starting point. In this post, we’ll focus on enabling this method to get you started quickly and effectively. In future posts, we’ll explore how to work with other authentication providers to expand your app’s capabilities. Here’s how to enable the email/password identity provider:\n\nLog in to the Google Cloud console, and search for “Identity Platform” using the search bar. Click on the “Identity Platform” service.\n\n\n\nClick the “ENABLE IDENTITY PLATFORM” button to activate the service.\n\n\n\nTo add an identity provider, click “ADD A PROVIDER”.\n\n\n\nFrom the dropdown menu, select and click “Email / Password”.\n\n\n\nConfigure the email provider settings. The default options should work perfectly for most use cases. Once configured, click “SAVE”.\n\n\n\nAfter saving, click “APPLICATION SETUP DETAILS” to access the service’s API key.\n\n\n\nCopy the “apiKey” and store it securely. This key will be used in your applications to authenticate with the Identity Platform.\n\n\n\nThat’s it! Your GCP Identity Platform is now set up with the Email/Password authentication provider, ready for use in your R projects.\n\n\n\n\n\n\nNow that the Identity Platform is set up, you can integrate authentication into your R projects using the API key, also referred as “FIREBASE_API_KEY”. First, set your Firebase API key as an environment variable.\nSys.setenv(FIREBASE_API_KEY = \"your-apiKey-here\")\nWith the API key in place, you have multiple options for integrating authentication into your R projects. You can either use the custom functions provided below, which directly interact with the Firebase Auth REST API, or opt for the firebase R package for a more streamlined approach.\nThe following custom functions demonstrate how to handle common authentication tasks such as signing in, signing up, resetting passwords, verifying emails, and fetching user data. These functions make secure API calls to the Firebase Auth REST API to interact with your GCP Identity Platform:\nbox::use(\n  httr[content, POST]\n)\n\nif (nchar(Sys.getenv(\"FIREBASE_API_KEY\")) == 0) {\n  stop(\"Set `FIREBASE_API_KEY` env var to handle user auths.\")\n}\n\napi_url &lt;- \"https://identitytoolkit.googleapis.com/v1/accounts\"\n\n#' Sign in with email / password\n#' @param email The email the user is signing in with.\n#' @param password The password for the account.\n#' @export\nemail_signin &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signInWithPassword?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Sign up with email / password\n#' @param email The email for the user to create.\n#' @param password The password for the user to create.\n#' @export\nemail_signup &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signUp?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send password reset email\n#' @param email User's email address.\n#' @export\nreset_password &lt;- function(email) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, requestType = \"PASSWORD_RESET\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send email verification\n#' @param id_token The Firebase ID token of the user to verify.\n#' @export\nemail_verification &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token, requestType = \"VERIFY_EMAIL\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Get user data\n#' @param id_token The Firebase ID token of the account.\n#' @export\nget_user_data &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":lookup?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res, as = \"parsed\", simplifyVector = TRUE)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\nThese functions make it easy to manage user authentication directly within your R projects, enabling secure sign-ins, sign-ups, password resets, email verification, and more.\nFor a full integration, you can test this functionality within a simple Shiny app:\n# App imports.\nbox::use(\n  shiny[\n    actionButton, br, conditionalPanel, div, fluidPage, modalButton, modalDialog, observeEvent,\n    outputOptions, passwordInput, reactive, reactiveVal, removeModal, renderText, req, shinyApp,\n    showModal, showNotification, textInput, verbatimTextOutput\n  ],\n  shinyvalidate[InputValidator, sv_email]\n)\n\n# UI definition for the app.\nui &lt;- fluidPage(\n  div(\n    align = \"center\",\n    br(),\n    # If it's logged in show \"Logout\", in the other case show \"Login\".\n    conditionalPanel(\"!output.logged_in\", actionButton(\"login\", \"Login / Signup\")),\n    conditionalPanel(\n      \"output.logged_in\",\n      # Displays a message with the logged-in user's email when logged in.\n      verbatimTextOutput(\"logged_msg\"),\n      actionButton(\"logout\", \"Logout\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  # Reactive value to store authentication status (whether user is logged in or not).\n  r_user_auth &lt;- reactiveVal(list(signed_in = FALSE))\n  # Reactive output to control the visibility of login/logout button based on auth status.\n  output$logged_in &lt;- reactive(r_user_auth()$signed_in)\n  outputOptions(output, \"logged_in\", suspendWhenHidden = FALSE)\n\n  # Modal dialog for login/signup.\n  auth_modal &lt;- modalDialog(\n    title = \"Login to Your Account\",\n    div(\n      align = \"center\",\n      # Inputs for email and password.\n      textInput(\"user_email\", label = NULL, placeholder = \"Email\", width = \"100%\"),\n      passwordInput(\"user_password\", label = NULL, placeholder = \"Password\", width = \"100%\"),\n      # Buttons for submitting login or signup request.\n      actionButton(\"login_submit\", \"Login\"),\n      actionButton(\"signup_submit\", \"Signup\"),\n      modalButton(\"Cancel\")\n    ),\n    footer = NULL,\n    easyClose = TRUE\n  )\n  # Input validation setup using shinyvalidate.\n  iv &lt;- InputValidator$new()\n  iv$add_rule(\"user_email\", sv_email())\n  # Custom password length validation.\n  sv_min_nchar &lt;- function(value) {\n    if (nchar(value) &lt; 8) {\n      \"The password must have at least 8 characters lenght\"\n    }\n  }\n  iv$add_rule(\"user_password\", sv_min_nchar)\n\n  # Server functions.\n  # Show the login modal when 'Login' is clicked.\n  observeEvent(input$login, showModal(auth_modal))\n  observeEvent(input$login_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    login_res &lt;- email_signin(user_email, user_pass)\n    if (!login_res$success) {\n      showNotification(\"Couldn't log in, please check your email and password!\", type = \"error\")\n    } else {\n      # On successful login, update user state and close modal.\n      user_data &lt;- get_user_data(login_res$idToken) # Fetch user data.\n      user_data$signed_in &lt;- TRUE\n      r_user_auth(user_data)\n      removeModal()\n    }\n  })\n  observeEvent(input$signup_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    signup_res &lt;- email_signup(user_email, user_pass)\n    if (!signup_res$success) {\n      showNotification(\"Couldn't sign up, please check your email and password!\", type = \"error\")\n    } else {\n      showNotification(\"Signed up, succesfully! Please login now.\")\n    }\n  })\n  observeEvent(input$logout, {\n    showNotification(\"Logged out, succesfully!\") # Notify user of successful logout.\n    r_user_auth(list(signed_in = FALSE)) # Reset auth status to logged out.\n  })\n\n  # Display logged-in user's email.\n  output$logged_msg &lt;- renderText({\n    req(r_user_auth()$signed_in) # Ensure the user is signed in.\n    paste0(\"Hi \", r_user_auth()$users$email, \"!\") # Greet the user by email.\n  })\n}\n\nshinyApp(ui, server)\nThis Shiny app integrates the authentication functions, allowing users to sign in, sign up, and log out, all while interacting with the GCP Identity Platform system. You can use this as a template to quickly build secure authentication workflows in your own applications."
  },
  {
    "objectID": "posts/add-user-auth/index.html#enable-google-cloud-platform-managed-user-auth",
    "href": "posts/add-user-auth/index.html#enable-google-cloud-platform-managed-user-auth",
    "title": "Enable Google Cloud Platform Managed User Auth",
    "section": "",
    "text": "In this post, we’ll walk through the process of enabling and configuring Google Cloud Platform’s (GCP) Identity Provider for R projects. Authentication and user management are critical for building secure and scalable applications. While it’s possible to implement your own authentication methods, doing so can introduce vulnerabilities, increase development time, and require ongoing maintenance to address security risks and compliance.\nGCP’s Identity Provider simplifies authentication workflows, offering a robust, managed solution that handles the heavy lifting for you. Whether you’re deploying Shiny apps, APIs, or R scripts on GCP, integrating a managed authentication service ensures ease of use, enhanced security, and scalability.\nThis guide provides a step-by-step approach to help you get started, leveraging GCP’s free-tier features wherever possible.\nLet’s dive in and set up secure user authentication for your R projects!\n\n\n\nThe email/password provider is the simplest authentication method to configure, making it an excellent starting point. In this post, we’ll focus on enabling this method to get you started quickly and effectively. In future posts, we’ll explore how to work with other authentication providers to expand your app’s capabilities. Here’s how to enable the email/password identity provider:\n\nLog in to the Google Cloud console, and search for “Identity Platform” using the search bar. Click on the “Identity Platform” service.\n\n\n\nClick the “ENABLE IDENTITY PLATFORM” button to activate the service.\n\n\n\nTo add an identity provider, click “ADD A PROVIDER”.\n\n\n\nFrom the dropdown menu, select and click “Email / Password”.\n\n\n\nConfigure the email provider settings. The default options should work perfectly for most use cases. Once configured, click “SAVE”.\n\n\n\nAfter saving, click “APPLICATION SETUP DETAILS” to access the service’s API key.\n\n\n\nCopy the “apiKey” and store it securely. This key will be used in your applications to authenticate with the Identity Platform.\n\n\n\nThat’s it! Your GCP Identity Platform is now set up with the Email/Password authentication provider, ready for use in your R projects.\n\n\n\n\n\n\nNow that the Identity Platform is set up, you can integrate authentication into your R projects using the API key, also referred as “FIREBASE_API_KEY”. First, set your Firebase API key as an environment variable.\nSys.setenv(FIREBASE_API_KEY = \"your-apiKey-here\")\nWith the API key in place, you have multiple options for integrating authentication into your R projects. You can either use the custom functions provided below, which directly interact with the Firebase Auth REST API, or opt for the firebase R package for a more streamlined approach.\nThe following custom functions demonstrate how to handle common authentication tasks such as signing in, signing up, resetting passwords, verifying emails, and fetching user data. These functions make secure API calls to the Firebase Auth REST API to interact with your GCP Identity Platform:\nbox::use(\n  httr[content, POST]\n)\n\nif (nchar(Sys.getenv(\"FIREBASE_API_KEY\")) == 0) {\n  stop(\"Set `FIREBASE_API_KEY` env var to handle user auths.\")\n}\n\napi_url &lt;- \"https://identitytoolkit.googleapis.com/v1/accounts\"\n\n#' Sign in with email / password\n#' @param email The email the user is signing in with.\n#' @param password The password for the account.\n#' @export\nemail_signin &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signInWithPassword?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Sign up with email / password\n#' @param email The email for the user to create.\n#' @param password The password for the user to create.\n#' @export\nemail_signup &lt;- function(email, password) {\n  post_res &lt;- POST(\n    paste0(api_url, \":signUp?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, password = password),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send password reset email\n#' @param email User's email address.\n#' @export\nreset_password &lt;- function(email) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(email = email, requestType = \"PASSWORD_RESET\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Send email verification\n#' @param id_token The Firebase ID token of the user to verify.\n#' @export\nemail_verification &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":sendOobCode?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token, requestType = \"VERIFY_EMAIL\"),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\n\n#' Get user data\n#' @param id_token The Firebase ID token of the account.\n#' @export\nget_user_data &lt;- function(id_token) {\n  post_res &lt;- POST(\n    paste0(api_url, \":lookup?key=\", Sys.getenv(\"FIREBASE_API_KEY\")),\n    body = list(idToken = id_token),\n    encode = \"json\"\n  )\n  post_content &lt;- content(post_res, as = \"parsed\", simplifyVector = TRUE)\n  post_content$success &lt;- post_res$status_code %in% 200:299\n  return(post_content)\n}\nThese functions make it easy to manage user authentication directly within your R projects, enabling secure sign-ins, sign-ups, password resets, email verification, and more.\nFor a full integration, you can test this functionality within a simple Shiny app:\n# App imports.\nbox::use(\n  shiny[\n    actionButton, br, conditionalPanel, div, fluidPage, modalButton, modalDialog, observeEvent,\n    outputOptions, passwordInput, reactive, reactiveVal, removeModal, renderText, req, shinyApp,\n    showModal, showNotification, textInput, verbatimTextOutput\n  ],\n  shinyvalidate[InputValidator, sv_email]\n)\n\n# UI definition for the app.\nui &lt;- fluidPage(\n  div(\n    align = \"center\",\n    br(),\n    # If it's logged in show \"Logout\", in the other case show \"Login\".\n    conditionalPanel(\"!output.logged_in\", actionButton(\"login\", \"Login / Signup\")),\n    conditionalPanel(\n      \"output.logged_in\",\n      # Displays a message with the logged-in user's email when logged in.\n      verbatimTextOutput(\"logged_msg\"),\n      actionButton(\"logout\", \"Logout\")\n    )\n  )\n)\n\nserver &lt;- function(input, output, session) {\n  # Reactive value to store authentication status (whether user is logged in or not).\n  r_user_auth &lt;- reactiveVal(list(signed_in = FALSE))\n  # Reactive output to control the visibility of login/logout button based on auth status.\n  output$logged_in &lt;- reactive(r_user_auth()$signed_in)\n  outputOptions(output, \"logged_in\", suspendWhenHidden = FALSE)\n\n  # Modal dialog for login/signup.\n  auth_modal &lt;- modalDialog(\n    title = \"Login to Your Account\",\n    div(\n      align = \"center\",\n      # Inputs for email and password.\n      textInput(\"user_email\", label = NULL, placeholder = \"Email\", width = \"100%\"),\n      passwordInput(\"user_password\", label = NULL, placeholder = \"Password\", width = \"100%\"),\n      # Buttons for submitting login or signup request.\n      actionButton(\"login_submit\", \"Login\"),\n      actionButton(\"signup_submit\", \"Signup\"),\n      modalButton(\"Cancel\")\n    ),\n    footer = NULL,\n    easyClose = TRUE\n  )\n  # Input validation setup using shinyvalidate.\n  iv &lt;- InputValidator$new()\n  iv$add_rule(\"user_email\", sv_email())\n  # Custom password length validation.\n  sv_min_nchar &lt;- function(value) {\n    if (nchar(value) &lt; 8) {\n      \"The password must have at least 8 characters lenght\"\n    }\n  }\n  iv$add_rule(\"user_password\", sv_min_nchar)\n\n  # Server functions.\n  # Show the login modal when 'Login' is clicked.\n  observeEvent(input$login, showModal(auth_modal))\n  observeEvent(input$login_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    login_res &lt;- email_signin(user_email, user_pass)\n    if (!login_res$success) {\n      showNotification(\"Couldn't log in, please check your email and password!\", type = \"error\")\n    } else {\n      # On successful login, update user state and close modal.\n      user_data &lt;- get_user_data(login_res$idToken) # Fetch user data.\n      user_data$signed_in &lt;- TRUE\n      r_user_auth(user_data)\n      removeModal()\n    }\n  })\n  observeEvent(input$signup_submit, {\n    iv$enable() # Enable input validation.\n    if (!iv$is_valid()) {\n      return() # If validation fails, exit early.\n    }\n    # If validation passes, attempt to log in.\n    user_email &lt;- trimws(input$user_email)\n    user_pass &lt;- input$user_password\n    signup_res &lt;- email_signup(user_email, user_pass)\n    if (!signup_res$success) {\n      showNotification(\"Couldn't sign up, please check your email and password!\", type = \"error\")\n    } else {\n      showNotification(\"Signed up, succesfully! Please login now.\")\n    }\n  })\n  observeEvent(input$logout, {\n    showNotification(\"Logged out, succesfully!\") # Notify user of successful logout.\n    r_user_auth(list(signed_in = FALSE)) # Reset auth status to logged out.\n  })\n\n  # Display logged-in user's email.\n  output$logged_msg &lt;- renderText({\n    req(r_user_auth()$signed_in) # Ensure the user is signed in.\n    paste0(\"Hi \", r_user_auth()$users$email, \"!\") # Greet the user by email.\n  })\n}\n\nshinyApp(ui, server)\nThis Shiny app integrates the authentication functions, allowing users to sign in, sign up, and log out, all while interacting with the GCP Identity Platform system. You can use this as a template to quickly build secure authentication workflows in your own applications."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html",
    "href": "posts/deploy-your-shiny-app/index.html",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "",
    "text": "In this blog post, we’ll guide you through deploying a Shiny app to production using Google Cloud Platform (GCP), leveraging services that are part of GCP’s free tier. Specifically, we’ll use Cloud Run and Artifact Registry, both of which offer generous free-tier allocations, allowing you to deploy and run your app at no cost, depending on your usage.\nFor this tutorial, we’ll use a simple dockerized Shiny app called everysinglecountry, which interacts with public APIs. This app doesn’t require a backend, database, or authentication, as we’ll cover these topics in future tutorials. If you’re interested in expanding your app with these features, stay tuned!\nBy the end of this tutorial, you’ll have your Shiny app running on GCP’s scalable infrastructure—completely within the free-tier limits.\n\n\nBefore we get started, ensure you have the following:\n\nAn active GCP account.\nThe gcloud command-line interface installed and configured.\nA dockerized Shiny app.\n\n\n\n\n\nEnable the “Artifact Registry API” and “Cloud Run” services.\nPush your Docker image to Google Artifact Registry.\nDeploy the image to Cloud Run for production."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html#deploy-your-shiny-app-on-google-cloud-platform",
    "href": "posts/deploy-your-shiny-app/index.html#deploy-your-shiny-app-on-google-cloud-platform",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "",
    "text": "In this blog post, we’ll guide you through deploying a Shiny app to production using Google Cloud Platform (GCP), leveraging services that are part of GCP’s free tier. Specifically, we’ll use Cloud Run and Artifact Registry, both of which offer generous free-tier allocations, allowing you to deploy and run your app at no cost, depending on your usage.\nFor this tutorial, we’ll use a simple dockerized Shiny app called everysinglecountry, which interacts with public APIs. This app doesn’t require a backend, database, or authentication, as we’ll cover these topics in future tutorials. If you’re interested in expanding your app with these features, stay tuned!\nBy the end of this tutorial, you’ll have your Shiny app running on GCP’s scalable infrastructure—completely within the free-tier limits.\n\n\nBefore we get started, ensure you have the following:\n\nAn active GCP account.\nThe gcloud command-line interface installed and configured.\nA dockerized Shiny app.\n\n\n\n\n\nEnable the “Artifact Registry API” and “Cloud Run” services.\nPush your Docker image to Google Artifact Registry.\nDeploy the image to Cloud Run for production."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html#lets-get-started",
    "href": "posts/deploy-your-shiny-app/index.html#lets-get-started",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "Let’s Get Started",
    "text": "Let’s Get Started\nOpen a terminal and navigate to the directory where your Shiny app is located:\n$ cd ~/Projects/everysinglecountry/\nEnsure that your Docker image is working as expected by running it locally. Visit http://localhost:8080 in your browser to test the app.\n$ docker run -p 8080:8080 everysinglecountry\nLog in to your GCP account using the following command. This will open a browser window where you must select the appropriate account for your project:\n$ gcloud auth login\n\nSelect your GCP account.\n\n\n\nClick “Continue”.\n\n\n\nClick “Allow” to grant the necessary permissions.\n\n\nInitialize the GCP account. Select the appropriate account and project (e.g., everysinglecountryproject@gmail.com and every-single-country respectively).\n$ gcloud init\nEnable the “Artifact Registry” service so you can push your Docker image:\n$ gcloud services enable artifactregistry.googleapis.com\nAuthenticate Docker to work with Google Artifact Registry:\n$ gcloud auth configure-docker\nTag your Docker image and push it to Artifact Registry:\n$ docker tag everysinglecountry gcr.io/every-single-country/everysinglecountry\n$ docker push gcr.io/every-single-country/everysinglecountry\nEnable the “Cloud Run” service to allow deployment of your Docker image:\n$ gcloud services enable run.googleapis.com\nNow, deploy the Docker image to Cloud Run. The --platform managed flag specifies that we’re using the fully managed version of Cloud Run. The --region us-central1 flag sets the region (I chose us-central1 because it works with Cloud Run Domain Mappings), and the --allow-unauthenticated flag makes the app accessible without authentication.\n$ gcloud run deploy everysinglecountry \\\n  --image gcr.io/every-single-country/everysinglecountry:latest \\\n  --platform managed \\\n  --region us-central1 \\\n  --allow-unauthenticated\nOnce the deployment is complete, Cloud Run will provide a “Service URL”. Open the URL in your browser to access your Shiny app, which is now publicly available.\n\nIn our example, you can test the deployed app at https://everysinglecountry-122108936732.us-central1.run.app/."
  },
  {
    "objectID": "posts/deploy-your-shiny-app/index.html#conclusion",
    "href": "posts/deploy-your-shiny-app/index.html#conclusion",
    "title": "Deploy Your Shiny App on Google Cloud Platform",
    "section": "Conclusion",
    "text": "Conclusion\nCongratulations! You’ve successfully deployed your Shiny app on Google Cloud Platform using Cloud Run. In the next post, we’ll dive into deploying Shiny apps with backend functions via Plumber RESTful APIs and discuss integrating databases for dynamic app functionality."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Blog",
    "section": "",
    "text": "Enable Cloud SQL Database\n\n\n\n\n\n\nGCP\n\n\nFree-Trial\n\n\nDatabase\n\n\n\nStep-by-step guide to enable and configure a Cloud SQL database in GCP.\n\n\n\n\n\nDec 26, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nEnable Google Analytics for Your Shiny App\n\n\n\n\n\n\nAnalytics\n\n\nFree-Tier\n\n\n\nLearn how to set up and configure Google Analytics for your Shiny apps to track user interactions and improve your app’s performance.\n\n\n\n\n\nDec 2, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nEnable Google Cloud Platform Managed User Auth\n\n\n\n\n\n\nAuth\n\n\nGCP\n\n\nFree-Tier\n\n\n\nLearn how to set up and configure Google Cloud Platform’s Identity Provider for your R projects. This guide covers secure user authentication using the Email/Password provider and offers practical examples for integration in R and Shiny apps.\n\n\n\n\n\nNov 26, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nAssign a Custom Domain to a Google Cloud Run Service\n\n\n\n\n\n\nDomain Names\n\n\nGCP\n\n\nFree-Tier\n\n\n\nLearn how to assign a custom domain to your Google Cloud Run Service for a professional and branded URL.\n\n\n\n\n\nNov 20, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nDeploy Your Shiny App on Google Cloud Platform\n\n\n\n\n\n\nShiny\n\n\nGCP\n\n\nFree-Tier\n\n\nDeployment\n\n\n\nA step-by-step guide to deploying a Shiny app on Google Cloud Platform using Artifact Registry and Cloud Run.\n\n\n\n\n\nNov 18, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\n\n\n\n\n\n\nCreate Your Google Cloud Account\n\n\n\n\n\n\nGCP\n\n\nFree-Tier\n\n\nAccounts\n\n\n\nLearn how to set up your Google Cloud Platform account to deploy R code to production. Get $300 in free credits with this step-by-step guide.\n\n\n\n\n\nNov 13, 2024\n\n\nJuan C. Rodriguez\n\n\n\n\n\n\nNo matching items"
  }
]